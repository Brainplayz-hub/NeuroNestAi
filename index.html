import os
import argparse
import json
import pathlib
from PIL import Image
import pytesseract
import pdfplumber
import docx
import google.generativeai as genai

# ==============================================================================
# ⚠️ CRITICAL SECURITY WARNING ⚠️
# The API key below is PUBLIC and COMPROMISED because you shared it.
# Anyone can use this key, which could lead to charges on your account.
#
# FOR YOUR SECURITY:
# 1. GO TO https://aistudio.google.com/app/apikey
# 2. DELETE THIS KEY IMMEDIATELY.
# 3. Create a new key and keep it PRIVATE.
#
# The BEST way to use your new key is to set it as an environment variable.
# This script will try to use an environment variable first before falling
# back to the hardcoded one.
#
# To set an environment variable:
# - Mac/Linux: export GOOGLE_API_KEY="YOUR_NEW_PRIVATE_KEY"
# - Windows:   setx GOOGLE_API_KEY "YOUR_NEW_PRIVATE_KEY"
# (You'll need to restart your terminal after setting it)
# ==============================================================================
API_KEY_HARDCODED = "AIzaSyCx2Pv1fLQQZPijxBR3GmtV_yRLCS_xllo"

def configure_api():
    """Configures the Google Gemini API."""
    api_key = os.getenv("GOOGLE_API_KEY", API_KEY_HARDCODED)
    if not api_key:
        print("🔴 ERROR: Google API Key not found.")
        print("Please set the GOOGLE_API_KEY environment variable or hardcode it in the script.")
        exit()
    
    if api_key == API_KEY_HARDCODED:
        print("🟡 WARNING: Using a hardcoded, public API key. Please switch to an environment variable for security.")

    try:
        genai.configure(api_key=api_key)
        print("✅ Google Gemini API configured successfully.")
    except Exception as e:
        print(f"🔴 ERROR: Failed to configure Gemini API: {e}")
        exit()

def extract_text_from_file(filepath: str) -> str:
    """
    Extracts text from various file types (.pdf, .docx, .txt, images).
    """
    path = pathlib.Path(filepath)
    if not path.exists():
        return f"Error: File not found at {filepath}"

    print(f"📄 Processing file: {path.name}...")
    extension = path.suffix.lower()
    
    try:
        if extension == ".pdf":
            with pdfplumber.open(path) as pdf:
                return "\n".join(page.extract_text() for page in pdf.pages if page.extract_text())
        elif extension == ".docx":
            doc = docx.Document(path)
            return "\n".join(para.text for para in doc.paragraphs if para.text)
        elif extension in [".jpg", ".jpeg", ".png", ".tiff", ".bmp"]:
            # Note: Tesseract must be installed on your system for this to work.
            # See instructions in the setup guide.
            return pytesseract.image_to_string(Image.open(path))
        elif extension == ".txt":
            return path.read_text(encoding='utf-8')
        else:
            return f"Error: Unsupported file type '{extension}'"
    except Exception as e:
        return f"Error processing file {path.name}: {e}"

def generate_study_materials(text: str, num_questions: int):
    """
    Generates a summary, Q&A pairs, and MCQs using the Gemini API.
    """
    if not text or len(text.strip()) < 50:
        print("🔴 ERROR: Input text is too short to generate study materials.")
        return

    print("\n🧠 Generating study materials with Gemini Pro...")
    
    try:
        model = genai.GenerativeModel('gemini-pro')

        # --- Generate Summary ---
        summary_prompt = f"""
        Summarize the following text clearly and concisely, capturing the main ideas. 
        The summary should be a single, well-written paragraph.

        Text:
        \"\"\"
        {text}
        \"\"\"
        """
        summary_response = model.generate_content(summary_prompt)
        summary = summary_response.text

        # --- Generate Q&A and MCQs ---
        qa_mcq_prompt = f"""
        Based on the text provided, generate exactly {num_questions} study questions.
        Return the output as a single valid JSON object with two keys: "qna_pairs" and "mcqs".

        - "qna_pairs": A list of objects, where each object has a "question" and an "answer".
        - "mcqs": A list of objects, where each object has "question_text", an "options" object (with keys "A", "B", "C", "D"), and a "correct_answer" key (e.g., "A").

        Text:
        \"\"\"
        {text}
        \"\"\"
        """
        qa_mcq_response = model.generate_content(qa_mcq_prompt)
        
        # Clean the response to ensure it's valid JSON
        json_response_text = qa_mcq_response.text.strip().replace("```json", "").replace("```", "")
        questions_data = json.loads(json_response_text)

        # --- Print Results ---
        print("\n" + "="*50)
        print("✨ Your Study Kit ✨")
        print("="*50)

        print("\n## 📝 Summary")
        print("-" * 20)
        print(summary)

        print("\n\n## ❓ Questions & Answers")
        print("-" * 20)
        for i, qa in enumerate(questions_data.get("qna_pairs", []), 1):
            print(f"{i}. Question: {qa['question']}")
            print(f"   Answer: {qa['answer']}\n")

        print("\n## ✅ Multiple-Choice Questions")
        print("-" * 20)
        for i, mcq in enumerate(questions_data.get("mcqs", []), 1):
            print(f"{i}. {mcq['question_text']}")
            for key, value in mcq['options'].items():
                print(f"   {key}) {value}")
            print(f"   Correct Answer: {mcq['correct_answer']}\n")

    except json.JSONDecodeError:
        print("🔴 ERROR: The model returned an invalid JSON format for questions. Please try again.")
        print("Raw model output:", qa_mcq_response.text)
    except Exception as e:
        print(f"🔴 An error occurred while generating content: {e}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="NeuroNest AI: Generate study materials from text or files.")
    parser.add_argument("--file", type=str, help="Path to a file (.txt, .pdf, .docx, .png, .jpg) to process.")
    parser.add_argument("--text", type=str, help="A string of text to process directly.")
    parser.add_argument("--num_questions", type=int, default=5, help="Number of questions to generate for Q&A and MCQs.")
    
    args = parser.parse_args()

    configure_api()

    input_text = ""
    if args.file:
        input_text = extract_text_from_file(args.file)
    elif args.text:
        input_text = args.text
    else:
        print("🔴 ERROR: No input provided. Please use --file or --text.")
        parser.print_help()
        exit()

    if input_text.startswith("Error:"):
        print(f"🔴 {input_text}")
    else:
        generate_study_materials(input_text, args.num_questions)
